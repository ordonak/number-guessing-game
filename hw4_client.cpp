//Author: Kenneth Ordona
//Class: CPSC 341
//Name: hw4_client.cpp
//Description: This program simulates a number-guessing game between a client
//and a server. The user is asked for input as to what they think the three
//numbers generated by the server are. When they are done guessing the numbers are 
//sent back to the server and are tested for their correctness. If they are correct
//the user has won the game and will be tested to see if they have won quickly
//enough to be put on the leaderboard.

#include <unistd.h>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <iostream> 
#include <string>
#include <cmath>	
#include <sys/types.h> // size_t, ssize_t
#include <sys/socket.h> // socket funcs
#include <netinet/in.h> // sockaddr_in
#include <arpa/inet.h> // htons, inet_pton
#include <unistd.h>
#include <pthread.h>
#include <vector>
using namespace std;
//TO-DO: FIX SENDING OF LEADERBOARD

const int MAX_ARGS = 3;		//const int used to hold max number of args
const int PORT_ARG = 2;		//port index for arguments
const int IP_ARG = 1;		//port index used for IP address
const int MAX_NUM = 3;		//max number of guesses & people on leaderboard
const int MAXPORT = 11899;	//const int used to hold max port #
const int MINPORT = 11800;	//const int used to hold min port #

//roundResult which is returned from server
struct roundResult{
	int tooHigh;
	int tooLow;
	int equal;
};

//leaderBoard struct
struct leaderBoard{
	vector<string> names;
	vector<long> rCounts;
};

//(network order)conversion functions for roundResult
roundResult toNet(roundResult toConvert);
roundResult notNet(roundResult toConv);

//receive function for roundResult
roundResult recResult(int sock);

//receive and send functions for longs
long receiveLong(int sock);

http://www.reddit.com/user/Fruit_ofthe_Loom
void sendLong(long num, int sock);

//receive and output leaderBoard functions
void outputBoard(leaderBoard board);
leaderBoard recBoard(int sock);

//receive and send functions for strings
void sendString(string msg, int sock);
string recvString(int sock);

int main(int argc, char *argv[])
{
	//initializing variables to be used
	int status;		//used to check TCP functions
	bool won = false;	//checked to see if the user has won the game
	string nameHolder;	//used to hold the users name
	string vicMess;		//used to hold the victory message sent from server
	long roundCount = 0; //used to hold the roundCount of the game
	long numGuess[MAX_NUM];	//used to hold the user's guesses
	int numActual[MAX_NUM]; // used to hold the actual numbers sent from the server	
	bool goodInput;//used to test whether or not the input passed in is valid
	long tooHigh, tooLow, equal; //used to hold the comparisons between guesses & ac


	//checking to see if argc is correct
	if(argc != MAX_ARGS)
	{
		cerr << "Invalid number of arguments. Please input IP address for first arg, then port # for "
			<< " second one. Now exiting program.";
		exit(-1);
	}

	//getting and converting IP address & portnum
	//too usable format from arguments passed in
	//PORT
	unsigned short portNum = (unsigned short)strtoul(argv[PORT_ARG], NULL, 0);
	if(portNum > MAXPORT|| portNum < MINPORT)
	{
		cerr << "This port is not assigned to Ken's program. Please try again with " << endl
			<<"numbers that are between 11800 & 11899. Now exiting. ";
		exit(-1);
	}
	//IP
	unsigned long servIP;
	status = inet_pton(AF_INET, argv[IP_ARG], &servIP);
	if (status <= 0) 
		exit(-1);
	struct sockaddr_in servAddr;
	servAddr.sin_family = AF_INET; // always AF_INET
	servAddr.sin_addr.s_addr = servIP;
	servAddr.sin_port = htons(portNum);

	//initializing the socket & checking if there is an error
	int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); //creating socket
	if (sock < 0) {
		cerr << "Error with socket" << endl;
		exit (-1);
	}

	cerr << "Welcome to the number-guessing game! Now attempting to connect to server! " << endl << endl;

	//connecting to ipAddress with given socket
	status = connect(sock, (struct sockaddr*) &servAddr, sizeof(servAddr));
	if (status < 0) {
		cerr << "Error with connect" << endl;
		exit (-1);
	}

	//connected, outputting welcome message
	cerr << "Connected! " << endl << endl;
	cerr << "In order to win this game you must correctly guess the value of three numbers that are sent " 
		<< "via our main-server."<< endl; 

	//receiving name of user & sending it to the server
	cerr << "What is your name: ";
	cin >> nameHolder;
	sendString(nameHolder, sock);

	cerr << "Welcome " << nameHolder << "! Time to guess your numbers!(Between 1-200) " << endl;

	//do-while loop for user's guesses & server-client checking
	//round-count is used in this loop for simple turn-checking
	do{
		cerr << "This is turn " << (roundCount+1) << endl; 
		for(int i = 0; i < MAX_NUM; i++){
			cerr << "Guess " << (i+1) << ": ";
			goodInput = false;

			//check if input is invalid - if so, try again
			while(!goodInput)
			{
				if(cin >> numGuess[i] && !(numGuess[i] > 200 || numGuess[i] < 1))
					goodInput = true;
				else
				{
					cerr << "Invalid Input. Input must be between 1-200(only integers)." << endl;
					cerr << "Try again: ";
					cin.clear();
					cin.ignore();
				}
			}
			//input is good, send it to server
			sendLong(numGuess[i], sock);
		}
		//receiving roundResult from server
		roundResult tempRes = recResult(sock);
		//checking if user has won based on roundResult
		if(tempRes.equal == 3){
			won = true;
			vicMess = recvString(sock);
		}
		//outputting scores of guess
		cerr << endl << "Too high: " << tempRes.tooHigh << "   Too low: " 
			<< tempRes.tooLow << "   Equal: " << tempRes.equal << endl << endl;
		roundCount++;
	}
	while(!won);

	//receiving roundCount from server to make sure there are no discrepancies
	//between client and server
	roundCount = receiveLong(sock);
	//writing victory message to console
	cerr << vicMess << "in " << roundCount << " turns!" << endl;

	//receiving and outputting leaderBoard
	leaderBoard currBoard = recBoard(sock);
	outputBoard(currBoard);

	//closing socket
	status = close(sock);
	if (status < 0) {
		cerr << "Error with close" << endl;
		exit (-1);
	}
}

roundResult toNet(roundResult toConvert)
{
	toConvert.tooHigh = htonl(toConvert.tooHigh);
	toConvert.tooLow = htonl(toConvert.tooLow);
	toConvert.equal = htonl(toConvert.equal);

	return toConvert;
}

roundResult notNet(roundResult toConv)
{
	toConv.tooHigh = ntohl(toConv.tooHigh);
	toConv.tooLow = ntohl(toConv.tooLow);
	toConv.equal = ntohl(toConv.equal);

	return toConv;
}


void sendLong(long num, int sock)
{
	long temp = htonl(num);
	int bytesSent = send(sock, (void *) &temp, sizeof(long), 0);
	if (bytesSent != sizeof(long)) 
		exit(-1);

}

roundResult recResult(int sock)
{
	roundResult tempRes;
	roundResult *rPointer = &tempRes;
	int bytesLeft = sizeof(tempRes);
	while(bytesLeft > 0)
	{
		int bytesRecv = recv(sock, (void*)rPointer, sizeof(tempRes), 0);
		if(bytesRecv <= 0){
			cerr << "Error receiving results. Now exiting program.";
			cin.get();
			exit(-1);
		}
		bytesLeft = bytesLeft - bytesRecv;
	}
	tempRes = *rPointer;
	tempRes = notNet(tempRes);
	return tempRes;
}

leaderBoard recBoard(int sock)
{
	leaderBoard tempBoard;
	for(int i = 0; i < MAX_NUM; i++)
	{
		tempBoard.rCounts.push_back(receiveLong(sock));
		tempBoard.names.push_back(recvString(sock));
	}
	return tempBoard;
}

void outputBoard(leaderBoard board)
{
	cerr << endl << endl;
	cerr << "LeaderBoard" << endl << "-----------" << endl;
	for(int i = 0; i < MAX_NUM; i++)
	{
		if(board.rCounts[i] != 0)
			cerr << board.names[i] <<  "     " << board.rCounts[i] << endl;
	}
}
long receiveLong(int sock)
{
	int bytesLeft = sizeof(long);
	long networkInt;	
	char *bp = (char*) &networkInt;

	while(bytesLeft > 0)
	{
		int bytesRecv = recv(sock, (void*)bp, bytesLeft, 0);
		if(bytesRecv <= 0){
			break;
		}
		else{
			bytesLeft = bytesLeft - bytesRecv;
			bp = bp + 
				bytesRecv;
		}
	}
	networkInt = ntohl(networkInt);
	return networkInt;
}

void sendString(string msg, int sock)
{
	long msgSize = (msg.length() + 1);
	char msgSend[msgSize];
	strcpy(msgSend, msg.c_str());

	sendLong(msgSize, sock);
	int bytesSent =  send(sock, (void *)msgSend, msgSize, 0);
	if (bytesSent != msgSize)
		exit(-1);
}

string recvString(int sock)
{
	int bytesLeft = receiveLong(sock);
	char msg[bytesLeft];
	char *bp = (char*)&msg;
	string temp;
	while(bytesLeft > 0)
	{	
		int bytesRecv = recv(sock, (void*)bp, bytesLeft, 0);
		if(bytesRecv <= 0)
			break;
		else{
			bytesLeft = bytesLeft - bytesRecv;
			bp = bp + bytesRecv;
		}
	}

	temp = string(msg);
	return temp;
}
